import {
  Injectable,
  InternalServerErrorException,
  Logger,
  NotFoundException
} from "@nestjs/common";
import { Prisma } from "@prisma/client";
import { NotFoundError } from "@prisma/client/runtime";
import { randomUUID } from "crypto";
import { PrismaError } from "prisma-error-enum";
import { PrismaService } from "src/prisma/prisma.service";

@Injectable()
export class TokensService {
  private readonly logger = new Logger(TokensService.name);

  constructor(private prisma: PrismaService) {}

  private handleQueryException(error: any) {
    this.logger.error(error);
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === PrismaError.RecordDoesNotExist)
        throw new NotFoundException("Token does not exist");
      else if (error.code === PrismaError.RecordsNotFound)
        throw new NotFoundException("Token not found");
    }
    throw new InternalServerErrorException("An error has occured");
  }

  /**
   * Generates a new submission token and credited to the user
   * @param userId User to generate token for
   */
  async generateTokenForUser(userId: number) {
    return await this.prisma.token.create({
      data: {
        token: randomUUID(),
        user: {
          connect: {
            id: userId
          }
        }
      }
    });
  }

  /**
   * Generates a new submission token (for form applications)
   */
  async generateToken() {
    return await this.prisma.token.create({
      data: {
        token: randomUUID()
      }
    });
  }

  /**
   * Gets the token by ID
   * @param tokenId ID of the token
   */
  async getToken(tokenId: number) {
    try {
      return await this.prisma.token.findUniqueOrThrow({
        where: { id: tokenId }
      });
    } catch (error) {
      this.handleQueryException(error);
    }
  }

  /**
   * Revokes the token
   * @param tokenId ID of the token to remove
   * @returns
   */
  async removeToken(tokenId: number) {
    return await this.prisma.token.delete({ where: { id: tokenId } });
  }

  /**
   * Gets all created tokens
   */
  async allTokens() {
    return await this.prisma.token.findMany();
  }

  /**
   * Gets all tokens generated by a user
   * @param userId ID of the user
   */
  async getUserTokens(userId: number) {
    return await this.prisma.token.findMany({ where: { userId } });
  }

  /**
   * Verifies if a token exists and valid for submission (not used before)
   * @param token Token to validate
   */
  async isTokenValidForSubmission(token: string) {
    const validToken = await this.prisma.token.findFirst({
      where: { token, submissions: { none: {} } }
    });

    return !!validToken;
  }
}
